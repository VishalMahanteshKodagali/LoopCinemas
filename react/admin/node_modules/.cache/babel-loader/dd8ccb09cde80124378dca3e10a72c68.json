{"ast":null,"code":"import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"react\";\nimport { equal } from \"@wry/equality\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nexport function useSubscription(subscription, options) {\n  var hasIssuedDeprecationWarningRef = React.useRef(false);\n  var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);\n  verifyDocumentType(subscription, DocumentType.Subscription);\n\n  var _a = React.useState({\n    loading: !(options === null || options === void 0 ? void 0 : options.skip),\n    error: void 0,\n    data: void 0,\n    variables: options === null || options === void 0 ? void 0 : options.variables\n  }),\n      result = _a[0],\n      setResult = _a[1];\n\n  if (!hasIssuedDeprecationWarningRef.current) {\n    hasIssuedDeprecationWarningRef.current = true;\n\n    if (options === null || options === void 0 ? void 0 : options.onSubscriptionData) {\n      globalThis.__DEV__ !== false && invariant.warn(options.onData ? 50 : 51);\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.onSubscriptionComplete) {\n      globalThis.__DEV__ !== false && invariant.warn(options.onComplete ? 52 : 53);\n    }\n  }\n\n  var _b = React.useState(function () {\n    if (options === null || options === void 0 ? void 0 : options.skip) {\n      return null;\n    }\n\n    return client.subscribe({\n      query: subscription,\n      variables: options === null || options === void 0 ? void 0 : options.variables,\n      fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,\n      context: options === null || options === void 0 ? void 0 : options.context\n    });\n  }),\n      observable = _b[0],\n      setObservable = _b[1];\n\n  var canResetObservableRef = React.useRef(false);\n  React.useEffect(function () {\n    return function () {\n      canResetObservableRef.current = true;\n    };\n  }, []);\n  var ref = React.useRef({\n    client: client,\n    subscription: subscription,\n    options: options\n  });\n  React.useEffect(function () {\n    var _a, _b, _c, _d;\n\n    var shouldResubscribe = options === null || options === void 0 ? void 0 : options.shouldResubscribe;\n\n    if (typeof shouldResubscribe === \"function\") {\n      shouldResubscribe = !!shouldResubscribe(options);\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.skip) {\n      if (!(options === null || options === void 0 ? void 0 : options.skip) !== !((_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.skip) || canResetObservableRef.current) {\n        setResult({\n          loading: false,\n          data: void 0,\n          error: void 0,\n          variables: options === null || options === void 0 ? void 0 : options.variables\n        });\n        setObservable(null);\n        canResetObservableRef.current = false;\n      }\n    } else if (shouldResubscribe !== false && (client !== ref.current.client || subscription !== ref.current.subscription || (options === null || options === void 0 ? void 0 : options.fetchPolicy) !== ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || !(options === null || options === void 0 ? void 0 : options.skip) !== !((_c = ref.current.options) === null || _c === void 0 ? void 0 : _c.skip) || !equal(options === null || options === void 0 ? void 0 : options.variables, (_d = ref.current.options) === null || _d === void 0 ? void 0 : _d.variables)) || canResetObservableRef.current) {\n      setResult({\n        loading: true,\n        data: void 0,\n        error: void 0,\n        variables: options === null || options === void 0 ? void 0 : options.variables\n      });\n      setObservable(client.subscribe({\n        query: subscription,\n        variables: options === null || options === void 0 ? void 0 : options.variables,\n        fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,\n        context: options === null || options === void 0 ? void 0 : options.context\n      }));\n      canResetObservableRef.current = false;\n    }\n\n    Object.assign(ref.current, {\n      client: client,\n      subscription: subscription,\n      options: options\n    });\n  }, [client, subscription, options, canResetObservableRef.current]);\n  React.useEffect(function () {\n    if (!observable) {\n      return;\n    }\n\n    var subscriptionStopped = false;\n    var subscription = observable.subscribe({\n      next: function (fetchResult) {\n        var _a, _b;\n\n        if (subscriptionStopped) {\n          return;\n        }\n\n        var result = {\n          loading: false,\n          data: fetchResult.data,\n          error: void 0,\n          variables: options === null || options === void 0 ? void 0 : options.variables\n        };\n        setResult(result);\n\n        if ((_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onData) {\n          ref.current.options.onData({\n            client: client,\n            data: result\n          });\n        } else if ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onSubscriptionData) {\n          ref.current.options.onSubscriptionData({\n            client: client,\n            subscriptionData: result\n          });\n        }\n      },\n      error: function (error) {\n        var _a, _b;\n\n        if (!subscriptionStopped) {\n          setResult({\n            loading: false,\n            data: void 0,\n            error: error,\n            variables: options === null || options === void 0 ? void 0 : options.variables\n          });\n          (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);\n        }\n      },\n      complete: function () {\n        var _a, _b;\n\n        if (!subscriptionStopped) {\n          if ((_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onComplete) {\n            ref.current.options.onComplete();\n          } else if ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onSubscriptionComplete) {\n            ref.current.options.onSubscriptionComplete();\n          }\n        }\n      }\n    });\n    return function () {\n      subscriptionStopped = true;\n      setTimeout(function () {\n        subscription.unsubscribe();\n      });\n    };\n  }, [observable]);\n  return result;\n}","map":{"version":3,"mappings":"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","names":["invariant","React","equal","DocumentType","verifyDocumentType","useApolloClient","useSubscription","subscription","options","hasIssuedDeprecationWarningRef","useRef","client","Subscription","useState","loading","skip","error","data","variables","result","setResult","current","onSubscriptionData","globalThis","query","fetchPolicy","context","_b","setObservable","canResetObservableRef","ref","_a","_c","_d","shouldResubscribe","subscriptionStopped","observable","next","fetchResult","onData","subscriptionData","onSubscriptionComplete","setTimeout"],"sources":["/Users/vishalmahanteshkodagali/Documents/RMIT/Sem 3/Full Stack Development/Assignment/Git_s3895036/loop-web-s3904406/react/admin/node_modules/@apollo/src/react/hooks/useSubscription.ts"],"sourcesContent":["import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"react\";\nimport type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  NoInfer,\n  SubscriptionHookOptions,\n  SubscriptionResult,\n} from \"../types/types.js\";\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\nexport function useSubscription<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  subscription: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SubscriptionHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n) {\n  const hasIssuedDeprecationWarningRef = React.useRef(false);\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(subscription, DocumentType.Subscription);\n  const [result, setResult] = React.useState<\n    SubscriptionResult<TData, TVariables>\n  >({\n    loading: !options?.skip,\n    error: void 0,\n    data: void 0,\n    variables: options?.variables,\n  });\n\n  if (!hasIssuedDeprecationWarningRef.current) {\n    hasIssuedDeprecationWarningRef.current = true;\n\n    if (options?.onSubscriptionData) {\n      invariant.warn(\n        options.onData\n          ? \"'useSubscription' supports only the 'onSubscriptionData' or 'onData' option, but not both. Only the 'onData' option will be used.\"\n          : \"'onSubscriptionData' is deprecated and will be removed in a future major version. Please use the 'onData' option instead.\"\n      );\n    }\n\n    if (options?.onSubscriptionComplete) {\n      invariant.warn(\n        options.onComplete\n          ? \"'useSubscription' supports only the 'onSubscriptionComplete' or 'onComplete' option, but not both. Only the 'onComplete' option will be used.\"\n          : \"'onSubscriptionComplete' is deprecated and will be removed in a future major version. Please use the 'onComplete' option instead.\"\n      );\n    }\n  }\n\n  const [observable, setObservable] = React.useState(() => {\n    if (options?.skip) {\n      return null;\n    }\n\n    return client.subscribe({\n      query: subscription,\n      variables: options?.variables,\n      fetchPolicy: options?.fetchPolicy,\n      context: options?.context,\n    });\n  });\n\n  const canResetObservableRef = React.useRef(false);\n  React.useEffect(() => {\n    return () => {\n      canResetObservableRef.current = true;\n    };\n  }, []);\n\n  const ref = React.useRef({ client, subscription, options });\n  React.useEffect(() => {\n    let shouldResubscribe = options?.shouldResubscribe;\n    if (typeof shouldResubscribe === \"function\") {\n      shouldResubscribe = !!shouldResubscribe(options!);\n    }\n\n    if (options?.skip) {\n      if (\n        !options?.skip !== !ref.current.options?.skip ||\n        canResetObservableRef.current\n      ) {\n        setResult({\n          loading: false,\n          data: void 0,\n          error: void 0,\n          variables: options?.variables,\n        });\n        setObservable(null);\n        canResetObservableRef.current = false;\n      }\n    } else if (\n      (shouldResubscribe !== false &&\n        (client !== ref.current.client ||\n          subscription !== ref.current.subscription ||\n          options?.fetchPolicy !== ref.current.options?.fetchPolicy ||\n          !options?.skip !== !ref.current.options?.skip ||\n          !equal(options?.variables, ref.current.options?.variables))) ||\n      canResetObservableRef.current\n    ) {\n      setResult({\n        loading: true,\n        data: void 0,\n        error: void 0,\n        variables: options?.variables,\n      });\n      setObservable(\n        client.subscribe({\n          query: subscription,\n          variables: options?.variables,\n          fetchPolicy: options?.fetchPolicy,\n          context: options?.context,\n        })\n      );\n      canResetObservableRef.current = false;\n    }\n\n    Object.assign(ref.current, { client, subscription, options });\n  }, [client, subscription, options, canResetObservableRef.current]);\n\n  React.useEffect(() => {\n    if (!observable) {\n      return;\n    }\n\n    let subscriptionStopped = false;\n    const subscription = observable.subscribe({\n      next(fetchResult) {\n        if (subscriptionStopped) {\n          return;\n        }\n\n        const result = {\n          loading: false,\n          // TODO: fetchResult.data can be null but SubscriptionResult.data\n          // expects TData | undefined only\n          data: fetchResult.data!,\n          error: void 0,\n          variables: options?.variables,\n        };\n        setResult(result);\n\n        if (ref.current.options?.onData) {\n          ref.current.options.onData({\n            client,\n            data: result,\n          });\n        } else if (ref.current.options?.onSubscriptionData) {\n          ref.current.options.onSubscriptionData({\n            client,\n            subscriptionData: result,\n          });\n        }\n      },\n      error(error) {\n        if (!subscriptionStopped) {\n          setResult({\n            loading: false,\n            data: void 0,\n            error,\n            variables: options?.variables,\n          });\n          ref.current.options?.onError?.(error);\n        }\n      },\n      complete() {\n        if (!subscriptionStopped) {\n          if (ref.current.options?.onComplete) {\n            ref.current.options.onComplete();\n          } else if (ref.current.options?.onSubscriptionComplete) {\n            ref.current.options.onSubscriptionComplete();\n          }\n        }\n      },\n    });\n\n    return () => {\n      // immediately stop receiving subscription values, but do not unsubscribe\n      // until after a short delay in case another useSubscription hook is\n      // reusing the same underlying observable and is about to subscribe\n      subscriptionStopped = true;\n      setTimeout(() => {\n        subscription.unsubscribe();\n      });\n    };\n  }, [observable]);\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}