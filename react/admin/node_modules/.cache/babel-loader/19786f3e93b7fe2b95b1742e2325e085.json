{"ast":null,"code":"import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\n\nfunction identity(document) {\n  return document;\n}\n\nvar DocumentTransform = function () {\n  function DocumentTransform(transform, options) {\n    if (options === void 0) {\n      options = Object.create(null);\n    }\n\n    this.resultCache = canUseWeakSet ? new WeakSet() : new Set();\n    this.transform = transform;\n\n    if (options.getCacheKey) {\n      this.getCacheKey = options.getCacheKey;\n    }\n\n    if (options.cache !== false) {\n      this.stableCacheKeys = new Trie(canUseWeakMap, function (key) {\n        return {\n          key: key\n        };\n      });\n    }\n  }\n\n  DocumentTransform.prototype.getCacheKey = function (document) {\n    return [document];\n  };\n\n  DocumentTransform.identity = function () {\n    return new DocumentTransform(identity, {\n      cache: false\n    });\n  };\n\n  DocumentTransform.split = function (predicate, left, right) {\n    if (right === void 0) {\n      right = DocumentTransform.identity();\n    }\n\n    return new DocumentTransform(function (document) {\n      var documentTransform = predicate(document) ? left : right;\n      return documentTransform.transformDocument(document);\n    }, {\n      cache: false\n    });\n  };\n\n  DocumentTransform.prototype.transformDocument = function (document) {\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n\n    var cacheEntry = this.getStableCacheEntry(document);\n\n    if (cacheEntry && cacheEntry.value) {\n      return cacheEntry.value;\n    }\n\n    checkDocument(document);\n    var transformedDocument = this.transform(document);\n    this.resultCache.add(transformedDocument);\n\n    if (cacheEntry) {\n      cacheEntry.value = transformedDocument;\n    }\n\n    return transformedDocument;\n  };\n\n  DocumentTransform.prototype.concat = function (otherTransform) {\n    var _this = this;\n\n    return new DocumentTransform(function (document) {\n      return otherTransform.transformDocument(_this.transformDocument(document));\n    }, {\n      cache: false\n    });\n  };\n\n  DocumentTransform.prototype.getStableCacheEntry = function (document) {\n    if (!this.stableCacheKeys) return;\n    var cacheKeys = this.getCacheKey(document);\n\n    if (cacheKeys) {\n      invariant(Array.isArray(cacheKeys), 63);\n      return this.stableCacheKeys.lookupArray(cacheKeys);\n    }\n  };\n\n  return DocumentTransform;\n}();\n\nexport { DocumentTransform };","map":{"version":3,"mappings":"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","names":["Trie","canUseWeakMap","canUseWeakSet","checkDocument","invariant","identity","document","transform","options","Object","create","WeakSet","Set","getCacheKey","cache","stableCacheKeys","key","DocumentTransform","predicate","left","right","documentTransform","transformDocument","resultCache","has","cacheEntry","getStableCacheEntry","value","transformedDocument","add","otherTransform","_this","cacheKeys","Array","isArray","lookupArray"],"sources":["/Users/vishalmahanteshkodagali/Documents/RMIT/Sem 3/Full Stack Development/Assignment/Git_s3895036/loop-web-s3904406/react/admin/node_modules/@apollo/src/utilities/graphql/DocumentTransform.ts"],"sourcesContent":["import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\nimport type { DocumentNode } from \"graphql\";\n\nexport type DocumentTransformCacheKey = ReadonlyArray<unknown>;\n\ntype TransformFn = (document: DocumentNode) => DocumentNode;\n\ninterface DocumentTransformOptions {\n  cache?: boolean;\n  getCacheKey?: (\n    document: DocumentNode\n  ) => DocumentTransformCacheKey | undefined;\n}\n\nfunction identity(document: DocumentNode) {\n  return document;\n}\n\nexport class DocumentTransform {\n  private readonly transform: TransformFn;\n\n  private readonly resultCache = canUseWeakSet\n    ? new WeakSet<DocumentNode>()\n    : new Set<DocumentNode>();\n\n  private stableCacheKeys:\n    | Trie<{ key: DocumentTransformCacheKey; value?: DocumentNode }>\n    | undefined;\n\n  // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n  private getCacheKey(\n    document: DocumentNode\n  ): DocumentTransformCacheKey | undefined {\n    return [document];\n  }\n\n  static identity() {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, { cache: false });\n  }\n\n  static split(\n    predicate: (document: DocumentNode) => boolean,\n    left: DocumentTransform,\n    right: DocumentTransform = DocumentTransform.identity()\n  ) {\n    return new DocumentTransform(\n      (document) => {\n        const documentTransform = predicate(document) ? left : right;\n\n        return documentTransform.transformDocument(document);\n      },\n      // Reasonably assume both `left` and `right` transforms handle their own caching\n      { cache: false }\n    );\n  }\n\n  constructor(\n    transform: TransformFn,\n    options: DocumentTransformOptions = Object.create(null)\n  ) {\n    this.transform = transform;\n\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n\n    if (options.cache !== false) {\n      this.stableCacheKeys = new Trie(canUseWeakMap, (key) => ({ key }));\n    }\n  }\n\n  transformDocument(document: DocumentNode) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n\n    const cacheEntry = this.getStableCacheEntry(document);\n\n    if (cacheEntry && cacheEntry.value) {\n      return cacheEntry.value;\n    }\n\n    checkDocument(document);\n\n    const transformedDocument = this.transform(document);\n\n    this.resultCache.add(transformedDocument);\n\n    if (cacheEntry) {\n      cacheEntry.value = transformedDocument;\n    }\n\n    return transformedDocument;\n  }\n\n  concat(otherTransform: DocumentTransform) {\n    return new DocumentTransform(\n      (document) => {\n        return otherTransform.transformDocument(\n          this.transformDocument(document)\n        );\n      },\n      // Reasonably assume both transforms handle their own caching\n      { cache: false }\n    );\n  }\n\n  getStableCacheEntry(document: DocumentNode) {\n    if (!this.stableCacheKeys) return;\n    const cacheKeys = this.getCacheKey(document);\n    if (cacheKeys) {\n      invariant(\n        Array.isArray(cacheKeys),\n        \"`getCacheKey` must return an array or undefined\"\n      );\n      return this.stableCacheKeys.lookupArray(cacheKeys);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}