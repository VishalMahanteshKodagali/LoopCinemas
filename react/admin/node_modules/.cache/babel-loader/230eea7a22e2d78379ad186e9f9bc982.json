{"ast":null,"code":"import { isReference, isField, DeepMerger, resultKeyNameFromField, shouldInclude, isNonNullObject, compact, createFragmentMap, getFragmentDefinitions, isArray } from \"../../utilities/index.js\";\nexport var hasOwn = Object.prototype.hasOwnProperty;\nexport function isNullish(value) {\n  return value === null || value === void 0;\n}\nexport { isArray };\nexport function defaultDataIdFromObject(_a, context) {\n  var __typename = _a.__typename,\n      id = _a.id,\n      _id = _a._id;\n\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = !isNullish(id) ? {\n        id: id\n      } : !isNullish(_id) ? {\n        _id: _id\n      } : void 0;\n    }\n\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n\n    if (!isNullish(id)) {\n      return \"\".concat(__typename, \":\").concat(typeof id === \"number\" || typeof id === \"string\" ? id : JSON.stringify(id));\n    }\n  }\n}\nvar defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  canonizeResults: false\n};\nexport function normalizeConfig(config) {\n  return compact(defaultConfig, config);\n}\nexport function shouldCanonizeResults(config) {\n  var value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\nexport function getTypenameFromStoreObject(store, objectOrReference) {\n  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, \"__typename\") : objectOrReference && objectOrReference.__typename;\n}\nexport var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nexport function fieldNameFromStoreName(storeFieldName) {\n  var match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\nexport function selectionSetMatchesResult(selectionSet, result, variables) {\n  if (isNonNullObject(result)) {\n    return isArray(result) ? result.every(function (item) {\n      return selectionSetMatchesResult(selectionSet, item, variables);\n    }) : selectionSet.selections.every(function (field) {\n      if (isField(field) && shouldInclude(field, variables)) {\n        var key = resultKeyNameFromField(field);\n        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));\n      }\n\n      return true;\n    });\n  }\n\n  return false;\n}\nexport function storeValueIsStoreObject(value) {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\nexport function extractFragmentContext(document, fragments) {\n  var fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap: fragmentMap,\n    lookupFragment: function (name) {\n      var def = fragmentMap[name];\n\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n\n      return def || null;\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["isReference","isField","DeepMerger","resultKeyNameFromField","shouldInclude","isNonNullObject","compact","createFragmentMap","getFragmentDefinitions","isArray","hasOwn","Object","prototype","hasOwnProperty","isNullish","value","defaultDataIdFromObject","_a","context","__typename","id","_id","keyObject","concat","JSON","stringify","defaultConfig","dataIdFromObject","addTypename","resultCaching","canonizeResults","normalizeConfig","config","shouldCanonizeResults","getTypenameFromStoreObject","store","objectOrReference","get","__ref","TypeOrFieldNameRegExp","fieldNameFromStoreName","storeFieldName","match","selectionSetMatchesResult","selectionSet","result","variables","every","item","selections","field","key","call","storeValueIsStoreObject","makeProcessedFieldsMerger","extractFragmentContext","document","fragments","fragmentMap","lookupFragment","name","def","lookup"],"sources":["/Users/vishalmahanteshkodagali/Documents/RMIT/Sem 3/Full Stack Development/Assignment/Git_s3895036/loop-web-s3904406/react/admin/node_modules/@apollo/src/cache/inmemory/helpers.ts"],"sourcesContent":["import type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type { NormalizedCache, InMemoryCacheConfig } from \"./types.js\";\n\nimport type { KeyFieldsContext } from \"./policies.js\";\nimport type { FragmentRegistryAPI } from \"./fragmentRegistry.js\";\n\nimport type {\n  Reference,\n  StoreValue,\n  StoreObject,\n  FragmentMap,\n  FragmentMapFunction,\n} from \"../../utilities/index.js\";\nimport {\n  isReference,\n  isField,\n  DeepMerger,\n  resultKeyNameFromField,\n  shouldInclude,\n  isNonNullObject,\n  compact,\n  createFragmentMap,\n  getFragmentDefinitions,\n  isArray,\n} from \"../../utilities/index.js\";\n\nexport const { hasOwnProperty: hasOwn } = Object.prototype;\n\nexport function isNullish(value: any): value is null | undefined {\n  return value === null || value === void 0;\n}\n\nexport { isArray };\n\nexport function defaultDataIdFromObject(\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext\n): string | undefined {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = !isNullish(id)\n        ? { id }\n        : !isNullish(_id)\n        ? { _id }\n        : void 0;\n    }\n\n    // If there is no object.id, fall back to object._id.\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n\n    if (!isNullish(id)) {\n      return `${__typename}:${\n        typeof id === \"number\" || typeof id === \"string\"\n          ? id\n          : JSON.stringify(id)\n      }`;\n    }\n  }\n}\n\nconst defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  // Thanks to the shouldCanonizeResults helper, this should be the only line\n  // you have to change to reenable canonization by default in the future.\n  canonizeResults: false,\n};\n\nexport function normalizeConfig(config: InMemoryCacheConfig) {\n  return compact(defaultConfig, config);\n}\n\nexport function shouldCanonizeResults(\n  config: Pick<InMemoryCacheConfig, \"canonizeResults\">\n): boolean {\n  const value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference\n): string | undefined {\n  return isReference(objectOrReference)\n    ? (store.get(objectOrReference.__ref, \"__typename\") as string)\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>\n): boolean {\n  if (isNonNullObject(result)) {\n    return isArray(result)\n      ? result.every((item) =>\n          selectionSetMatchesResult(selectionSet, item, variables)\n        )\n      : selectionSet.selections.every((field) => {\n          if (isField(field) && shouldInclude(field, variables)) {\n            const key = resultKeyNameFromField(field);\n            return (\n              hasOwn.call(result, key) &&\n              (!field.selectionSet ||\n                selectionSetMatchesResult(\n                  field.selectionSet,\n                  result[key],\n                  variables\n                ))\n            );\n          }\n          // If the selection has been skipped with @skip(true) or\n          // @include(false), it should not count against the matching. If\n          // the selection is not a field, it must be a fragment (inline or\n          // named). We will determine if selectionSetMatchesResult for that\n          // fragment when we get to it, so for now we return true.\n          return true;\n        });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue\n): value is StoreObject {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\n\nexport function extractFragmentContext(\n  document: DocumentNode,\n  fragments?: FragmentRegistryAPI\n): {\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n} {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap,\n    lookupFragment(name) {\n      let def: FragmentDefinitionNode | null = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}