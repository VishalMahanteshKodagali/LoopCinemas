{"ast":null,"code":"import * as React from \"react\";\nimport { unwrapQueryRef } from \"../cache/QueryReference.js\";\nimport { __use } from \"./internal/index.js\";\nimport { toApolloError } from \"./useSuspenseQuery.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nexport function useReadQuery(queryRef) {\n  var internalQueryRef = unwrapQueryRef(queryRef);\n  invariant(internalQueryRef.promiseCache, 49);\n  var promiseCache = internalQueryRef.promiseCache,\n      key = internalQueryRef.key;\n\n  if (!promiseCache.has(key)) {\n    promiseCache.set(key, internalQueryRef.promise);\n  }\n\n  var promise = useSyncExternalStore(React.useCallback(function (forceUpdate) {\n    return internalQueryRef.listen(function (promise) {\n      internalQueryRef.promiseCache.set(internalQueryRef.key, promise);\n      forceUpdate();\n    });\n  }, [internalQueryRef]), function () {\n    return promiseCache.get(key);\n  }, function () {\n    return promiseCache.get(key);\n  });\n\n  var result = __use(promise);\n\n  return React.useMemo(function () {\n    return {\n      data: result.data,\n      networkStatus: result.networkStatus,\n      error: toApolloError(result)\n    };\n  }, [result]);\n}","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,cAAT,QAA+B,4BAA/B;AAEA,SAASC,KAAT,QAAsB,qBAAtB;AACA,SAASC,aAAT,QAA8B,uBAA9B;AACA,SAASC,SAAT,QAA0B,kCAA1B;AACA,SAASC,oBAAT,QAAqC,2BAArC;AAEA,OAAM,SAAUC,YAAV,CAA8BC,QAA9B,EAA6D;EACjE,IAAMC,gBAAgB,GAAGP,cAAc,CAACM,QAAD,CAAvC;EACAH,SAAS,CACPI,gBAAgB,CAACC,YADV,EAEP,EAFO,CAAT;MAGIA;MAAAC;;MACA;IAGID,YAAY,IAAZ,CAAsBC,GAAtB,EAAsBF,gBAAgB,QAAtC;EAER;;MACEG,8BAAsB,mBAA0B;IACjD;MAEKH,gBAAU,aAAV,CACJI,GADI,CACEJ,gBACJ,IAFE,EAEDG,OAFC;MAGAE,WAAO;KALZ;GADuB,uBAQF;IAAA;EAAA,CARE,EAQF;IAAA;EAAA,CARE;;MASlBC,MAAG;;EACL,OACCd,cAAiB,YAEpB;IAII,OAAM;MAELe,IAAK,EAACD,MAAO,CAACC,IAFT;MAGVC,aAAO,sBAHG;MAIRC,KAAI,EAAEd,aAAW;IAJT,CAAN;GAND,WADD","names":["React","unwrapQueryRef","__use","toApolloError","invariant","useSyncExternalStore","useReadQuery","queryRef","internalQueryRef","promiseCache","key","promise","set","forceUpdate","result","data","networkStatus","error"],"sources":["/Users/vishalmahanteshkodagali/Documents/RMIT/Sem 3/Full Stack Development/Assignment/Git_s3895036/loop-web-s3904406/react/admin/node_modules/@apollo/src/react/hooks/useReadQuery.ts"],"sourcesContent":["import * as React from \"react\";\nimport { unwrapQueryRef } from \"../cache/QueryReference.js\";\nimport type { QueryReference } from \"../cache/QueryReference.js\";\nimport { __use } from \"./internal/index.js\";\nimport { toApolloError } from \"./useSuspenseQuery.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\nexport function useReadQuery<TData>(queryRef: QueryReference<TData>) {\n  const internalQueryRef = unwrapQueryRef(queryRef);\n  invariant(\n    internalQueryRef.promiseCache,\n    \"It appears that `useReadQuery` was used outside of `useBackgroundQuery`. \" +\n      \"`useReadQuery` is only supported for use with `useBackgroundQuery`. \" +\n      \"Please ensure you are passing the `queryRef` returned from `useBackgroundQuery`.\"\n  );\n\n  const { promiseCache, key } = internalQueryRef;\n\n  if (!promiseCache.has(key)) {\n    promiseCache.set(key, internalQueryRef.promise);\n  }\n\n  const promise = useSyncExternalStore(\n    React.useCallback(\n      (forceUpdate) => {\n        return internalQueryRef.listen((promise) => {\n          internalQueryRef.promiseCache!.set(internalQueryRef.key, promise);\n          forceUpdate();\n        });\n      },\n      [internalQueryRef]\n    ),\n    () => promiseCache.get(key)!,\n    () => promiseCache.get(key)!\n  );\n\n  const result = __use(promise);\n\n  return React.useMemo(() => {\n    return {\n      data: result.data,\n      networkStatus: result.networkStatus,\n      error: toApolloError(result),\n    };\n  }, [result]);\n}\n"]},"metadata":{},"sourceType":"module"}